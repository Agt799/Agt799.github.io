{"meta":{"title":"Agt Wiki","subtitle":null,"description":null,"author":"Agt","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-05-21T08:30:17.753Z","updated":"2018-05-21T08:30:17.753Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-21T08:30:17.755Z","updated":"2018-05-21T08:30:17.755Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-21T08:30:17.759Z","updated":"2018-05-21T08:30:17.759Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"归并排序","slug":"Engineer/归并排序","date":"2018-08-05T04:23:33.000Z","updated":"2018-08-05T05:46:10.409Z","comments":true,"path":"2018/08/05/Engineer/归并排序/","link":"","permalink":"http://yoursite.com/2018/08/05/Engineer/归并排序/","excerpt":"","text":"归并排序是一种遵循分治法思想，时间复杂度O(nlgn)的排序算法 原理基于分治模式 分解：分解待排序的n各元素的序列成各具n/2个元素的两个子序列 解决：使用归并排序递归地排序两个子序列 合并：合并两个已排列好的子序列来产生最终结果 伪代码//A:array, Left:p, Center:q, Right:rMERGE(A,p,q,r) n1 = q - p + 1 n2 = r - q let L[1...n1+1] and R[1..n2+1] be new arrays for i = 1 to n1 L[i] = A[p+i-1] for j = 1 to n2 R[j] = A[q+j] L[n1+1] = MAXIMUM R[n2+1] = MAXIMUM for k = p to r if L[i] &lt;= R[j] A[k] = L[i] i++ else A[k] = R[j] j++ MERGE_SORT(A,p,r) if p &lt; r q = p + r / 2 MERGE_SORT(A,p,q) MERGE_SORT(A,q+1,r) MERGE(A,p,q,r) 算法演示归并排序演示 循环不等式证明 针对Merge的循环，循环每次迭代时，子数组A[p..k-1]按照排序好的顺序（这里为非降序）包含了两个子数组L[1..n1+1]和R[1..n2+1]中的k-p个最小的元素，同时在每次循环中L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素 初始化：第一次迭代前，k==p，所以子数组A[p..k-1]为空；又i=j=1,所以L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素 保持：若L[i] &lt;= R[j],则将L[i]复制为A[k];同样若L[i] &gt; R[j]，则将R[i]复制回A[k];之后将k增加，则增大了子数组A[p..k-1]的范围，包含了刚刚以升序加入的值；同时i和j对应的自增1，指向现在未被复制回数组的最小元素 终止：此时k=r+1，根据循环不变式，子数组A[p..k-1]就是原数组A排序后的结果；且对于两个数组L和R，除了其中标志为MAXIMUM的两个哨兵值以外已全部回到原数组A 应用1.逆序对 在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。概括：如果a[i] &gt; a[j] 且 i &lt; j， a[i] 和 a[j] 构成一个逆序对。 CLRS 思考题2.4 LintCode 532 class Solution &#123;public: /** * @param A: an array * @return: total of reverse pairs */ long long reversePairs(vector&lt;int&gt; &amp;A) &#123; return mergeSortMod(A,0,A.size()-1); &#125; long long mergeSortMod(vector&lt;int&gt; &amp;A,int left, int right)&#123; if (left &lt; right)&#123; long long pairs = 0; int center = (left + right) / 2; pairs += mergeSortMod(A, left, center); pairs += mergeSortMod(A, center + 1, right); pairs += merge(A, left, center, right); return pairs; &#125; else return 0; &#125; long long merge(vector&lt;int&gt; &amp;A, int left, int center, int right) &#123; int indexL = left; int indexR = center + 1; int indexArray = 0; int size = right - left + 1; vector&lt;int&gt;tempArray(size); long long pairs = 0; while (indexL &lt;= center &amp;&amp; indexR &lt;= right) &#123; if (A.at(indexL) &gt; A.at(indexR)) &#123; tempArray[indexArray++] = A.at(indexR++); pairs += (center - indexL + 1); &#125; else &#123; tempArray[indexArray++] = A.at(indexL++); &#125; &#125; //add all the remaining number while (indexL &lt;= center) &#123; tempArray[indexArray++] = A.at(indexL++); &#125; while (indexR &lt;= right) &#123; tempArray[indexArray++] = A.at(indexR++); &#125; int boundSize = tempArray.size(); for (int i = 0; i &lt; boundSize; i++) &#123; A[i + left] = tempArray[i]; &#125; return pairs; &#125;&#125;;","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/tags/CLRS/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C1&2 算法基础","slug":"Note/算法导论/算法基础","date":"2018-08-03T11:28:23.000Z","updated":"2018-08-03T12:44:02.679Z","comments":true,"path":"2018/08/03/Note/算法导论/算法基础/","link":"","permalink":"http://yoursite.com/2018/08/03/Note/算法导论/算法基础/","excerpt":"","text":"算法的定义 非形式地说，算法就是把输入转换为输出的计算步骤的一个序列 或是说算法描述了一个特定的计算过程，该过程实现了某个计算问题所期望的输入/输出关系 NP完全问题NP完全(NPC或NP-Complete)问题，是NP（非决定性多项式时间）中最难的决定性问题。 可以在决定型依序机器上（例如图灵机）以多项式时间解决的决定性问题，其属于的复杂度类被称为P。 可以在多项式时间验证答案的决定性问题称为NP。 而NP也是可以在非确定型图灵机以多项式时间解决的问题（NP两字为Non-deterministic Polynomial的缩写）。 多项式时间 wikipedia NPC问题具有以下特性： 是否存在有效算法是未知的 若果一个NPC问题存在有效算法，那么所有NPC问题都存在有效算法（因为NPC问题之间可以通过转换输入/输出来进行归约） 算法基础循环不变式 loop invariant使用类似数学归纳法的思想，用来帮助我们理解算法的正确性 三条性质： 初始化：循环的第一次迭代之前，它为真 保持:如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真 终止：在循环终止的时候，不变式所处的状态有利于算法正确性的证明 增长量级若算法的运行时间估算表示为an^2+bn+c 我们做出更简化的抽象：只考虑对事件影响最大的项，如这里的an^2，因为在这里感兴趣的是运行事件的增长率或增长量级，所以进一步化简为O(n^2)(此处应为’theta’符号) 分治法 分治法思想：将原问题分解为几个规模较小但类似与原问题的子问题，递归地求解这些子问题，然后再合并这些子问题地解来简历原问题的解 递归时的三个步骤： 分解原问题 递归地解决各子问题，若子问题的规模足够小则直接求解 合并这些子问题的解成原问题的解 Tips of (CLRS) 伪代码 书中的循环计数器在退出循环后保留原值 布尔运算符都是短路的 NIL用作不指向任何对象的指针的特殊值 分析算法中假定一种通用的单处理器模型–随机访问处理器(Random-access machine,RAM)，该模型没有并发操作","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"算法导论","slug":"Note/算法导论","permalink":"http://yoursite.com/categories/Note/算法导论/"}],"tags":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/tags/CLRS/"}]},{"title":"第5章 [BX]和loop指令","slug":"Note/汇编语言/第5章 [BX]和loop指令","date":"2018-08-02T13:17:30.000Z","updated":"2018-08-03T04:46:48.286Z","comments":true,"path":"2018/08/02/Note/汇编语言/第5章 [BX]和loop指令/","link":"","permalink":"http://yoursite.com/2018/08/02/Note/汇编语言/第5章 [BX]和loop指令/","excerpt":"","text":"使用[bx]访问内存地址要完整的描述一个内存单元，需要知道： 内存单元的地址 内存单元的长度 （或是通过类型推断出长度） 类型推断长度 已知段地址默认保存在ds中，所以mov ax,[bx]可以将ds:bx处长度2个字节单元的数据移动到ax里。 而mov al,[bx]则将同一个起始位置长度1个字节单元的数据移动到al里。 Loop指令语法assume cs:codecode segment mov ax,0 mov cx,236s: add ax,123 loop s mov ax,4c00h int 21hcode endsend 其中cx内的值为循环次数，s：标识的位置为循环开始地址 执行loop指令的步骤 cx = cx -1 判断cx的值，若不为0则跳转至标号处执行，若为0则向下执行 安全空间在实模式下运行的设备并没有对硬件系统进行安全性检查的功能，所以可能出现系统级的数据或是程序被用户的汇编程序修改的问题，所以需要避开使用不安全的地址范围 在Dos下，一般0:200~0:2ff的空间是可以安全使用的 Tip 在汇编源程序中，数据不能以字母开头，要在数据前补一个’0’ ， A000h在源程序中要写为0A000h 地址表示法在debug与源程序中的不同 指令mov ax,[0]在Debug工具上表示将ds:0地址的数据送入ax寄存器 而在汇编源程序中被识别为mov ax,0，解决方式：使用显式地给出段寄存器，mov ax,ds:[0],前缀ds在这里被称为段前缀","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"汇编语言","slug":"Note/汇编语言","permalink":"http://yoursite.com/categories/Note/汇编语言/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"数据库主键的选择","slug":"Theory/数据库主键类型的选择","date":"2018-07-23T01:44:01.000Z","updated":"2018-08-02T13:07:11.513Z","comments":true,"path":"2018/07/23/Theory/数据库主键类型的选择/","link":"","permalink":"http://yoursite.com/2018/07/23/Theory/数据库主键类型的选择/","excerpt":"","text":"主键的作用保证了每行数据的唯一性，选择出主键让表达到了数据库标准化第一范式 UUID (Universally Unique Identifier)通用唯一识别码 UUID是一种软件架构的标准 由一组32位的16进制数据构成，形式为用连字号把32个数据分为8-4-4-12，故加上‘-’字符一共有36位数，例如123e4567-e89b-12d3-a456-426655440000 使用随机数算法以及巨大的密钥空间保证了UUID极低重复性 主键的选择 使用 自增int型 作为主键 使用 UUID 作为主键 使用自定义的介于二者之间","categories":[{"name":"Theory","slug":"Theory","permalink":"http://yoursite.com/categories/Theory/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"QT Note","slug":"Engineer/QT note1","date":"2018-07-21T16:15:01.000Z","updated":"2018-08-02T13:07:09.009Z","comments":true,"path":"2018/07/22/Engineer/QT note1/","link":"","permalink":"http://yoursite.com/2018/07/22/Engineer/QT note1/","excerpt":"","text":"QT简介QT是一个跨平台的C++引用程序开发框架 定位主要是C++的一个图形库，同时也可用于非GUI开发 GUI开发：由于QT构建的一个中间层，使用QT技术可以让开发人员编写的代码 “ 一次编写，处处运行 ”,在不同的平台下只需要重新编译即可运行， 并且会根据平台原生的UI风格自动调整程序的UI风格 非GUI开发： Qt使用标准的C++和特殊的代码生成扩展（称为元对象编译器（Meta Object Compiler, QT源代码在(C++编译器)编译前会先经过moc的编译，先生成扩展后的C++源代码，然后再编译链接为二进制运行。 跨平台的特性： ##","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"}]},{"title":"OpenCV C++环境搭建","slug":"Engineer/OpenCV-环境搭建","date":"2018-07-02T12:19:00.000Z","updated":"2018-07-23T02:00:04.398Z","comments":true,"path":"2018/07/02/Engineer/OpenCV-环境搭建/","link":"","permalink":"http://yoursite.com/2018/07/02/Engineer/OpenCV-环境搭建/","excerpt":"","text":"以下为在Windows系统下配置 C++描述的OpenCV库 下载OpenCV ：https://opencv.org/ 运行opencv_version.exe 将OpenCV项目源码以及链接库文件等解压到特定目录 在系统变量PATH中添加cv的bin目录,如D:\\OpenCV\\opencv\\build\\x64\\vc15\\bin(配置时需要确定本机上OpenCV所在的目录) 配置IDE Qt CreatorQT Creator 是一款敏捷&amp;强大的C++ IDE本身用的是C++/QT编写，所以在各平台都可以运行 在QT Creator中配置OpenCV3的步骤 在Pro文件中添加 #configure for opencvINCLUDEPATH += D:\\OpenCV\\opencv\\build\\includeLIBS+=D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib\\opencv_world341.libLIBS+=D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib\\opencv_world341d.lib 构建Kit选择MSVC版本的 运行DEMO，成功 Visual Studio 2017VS–宇宙最强IDE 调试功能强大 单元测试很方便 Live Share等功能很实用 … 唯一的缺点就是大 在Visual Studio2017中配置OpenCV3 C/C++ 附加包含目录D:\\OpenCV\\opencv\\build\\include 链接器 常规 附加库目录 D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 链接器 输入 附加依赖项 opencv_world341d.lib;%(AdditionalDependencies) 解决方案平台 X64 （OpenCV在Windows上目前只支持64位） 测试DEMO#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;int main()&#123; Mat img = imread(\"C:\\\\Users\\\\Agt\\\\Desktop\\\\PIC\\\\lena.jpg\"); namedWindow(\"image\", WINDOW_NORMAL); imshow(\"image\", img); waitKey(0); return 0;&#125;","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Simple MarkDown Note","slug":"Note/MarkDown Note","date":"2018-05-21T08:52:22.000Z","updated":"2018-08-02T13:14:47.809Z","comments":true,"path":"2018/05/21/Note/MarkDown Note/","link":"","permalink":"http://yoursite.com/2018/05/21/Note/MarkDown Note/","excerpt":"","text":"分级标题# 主标题## 二级标题### 三级标题 ...###### 六级标题 #与标题内容之间要有一个空格 列表无序列表- list1 - list2 + list3 + sublist1 + sublist2 + list4 list1 list2 list3 sublist1 sublist2 list4 有序列表1. first 1. 1.1 2. 1.2 2. second 3. third 4. fourth first 1.1 1.2 second third fourth 链接与图片插入链接[显示文本](链接地址)AgtWiki 插入图片![](图片链接地址)具体的图片链接地址需要上传到图床上后获得 代码块1. 三引号+编程语言名称 效果： 内容:import tensorflow as tftf.session() 2. Tab缩进法直接将一段代码全选然后tab缩进 bool DBManager::createConnection()&#123; QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(DB_NAME); // this version of SQLite is unable to encrypt // so the following two lines are useless db.setUserName(\"sqlite3\"); db.setPassword(\"sqlite\"); if (!db.open()) &#123; qDebug()&lt;&lt;\"SQLite didn't want to work : \"&lt;&lt;db.lastError().text(); return false; &#125; qDebug()&lt;&lt;\"Local database loaded!\"; return true;&#125; 2. 行内代码块在行内使用两个 ` 号 `print(“i am a single line code”)` 效果：print(&quot;i am a single line code&quot;) 粗体和斜体**粗体文字!（用两个星号包含）** 粗体文字! *斜体文字(用一个星号包含)* If you lost the powerful urge to learn, try to regain it 引用&gt; as the history goes ... some man will be immortal 效果： as the history goes …some man will be immortal 表格| Tables | Are | Cool |Test || ------------- |:-------------:| -----:|:--- || col 3 is | right-aligned | $1600 |true || col 2 is | centered | $12 |false|| zebra stripes | are neat | $1 |true | 效果： Tables Are Cool Test col 3 is right-aligned $1600 true col 2 is centered $12 false zebra stripes are neat $1 true","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]}